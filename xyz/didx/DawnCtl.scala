//> using toolkit typelevel:latest
//> using packaging.output "dawnctl"
//> using nativeMode "release-fast"
//> using dep io.circe::circe-core:0.14.6
//> using dep io.circe::circe-parser:0.14.6
//> using dep io.circe::circe-generic:0.14.6
//> using dep com.lihaoyi::os-lib:0.9.1

package xyz.didx


import cats.effect.*
import cats.syntax.all.*
import com.monovore.decline.*
import com.monovore.decline.effect.*
import io.circe.*
import io.circe.parser.*
import io.circe.syntax.*
import io.circe.generic.semiauto.*
import io.circe.Encoder.encodeJsonObject

import os.*

import fs2.*
import scala.util.Try


object DawnCtl extends CommandIOApp("dawnctl", "A command-line interface to your DWN Context") : 
  // case class Context(did: String)
  case class ContextEntry(did: String)

  given Encoder[ContextEntry] = deriveEncoder[ContextEntry]
  given Decoder[ContextEntry] = deriveDecoder[ContextEntry]

  case class ContextFile(entries:Map[String,ContextEntry])

  given Encoder[ContextFile] = deriveEncoder[ContextFile]
  given Decoder[ContextFile] = deriveDecoder[ContextFile]


  val prompt = ">> "
  val exitCommand = "exit"
  def generateDid(): Either[Throwable,String] = {
    // Replace with your logic to generate the DID
    Right("did:dwn:123456789abcdefghi")
  }

  val helpInformation: String = """
  |Usage: dawnctl [command] [options]
  |Command: init [optional-arg]
  |Initialize your DWN Context. A DID generated by the DWN Network will be stored in the Context file <$user.home/.dawn/dawn.conf>
  |Command: delete
  |Delete something
  |Command: get [optional-arg]
  |Get something
  |Command: relay
  |Relay something
  |Options:
  |  --help
  |    This help information
  """
  val user = System.getProperty("user.name")
  val userDir = os.home
  val dawnDir = userDir / ".dawn"
  val contextFilePath = dawnDir / "dawn.conf"
  val initCommand: Command[Unit] = Command("init", "Initialize your DWN Context. A DID generated by the DWN Network will be stored in the Context file <$user.home/.dawn/dawn.conf>") {
    val contextName = Opts.option[String]("context-name", "Context Name").withDefault(user)
    (contextName).map { arg => {
      // Check if the context file already exists
      val contextFileAndDid: Either[Throwable, (ContextFile, String)] = Try(os.exists(contextFilePath)).toEither.flatMap {
          case true => 
            //read the content of the file and parse the json to case class ContextFile 
            val contextFileContent = Right(os.read(contextFilePath))
            for 
              content <- contextFileContent
              json <- parse(content)
              cf <- json.as[ContextFile]
              // check if the context name already exists and return the did or generate a new did
              did <- cf.entries.get(arg) match {
                case Some(entry) => 
                  println(s"Context for $arg has already been initialized - ignore")
                  Left(new Exception(s"Context for $arg has already been initialized - ignore")  ) //Right(entry.did)
                case None => generateDid()
              }
              ncf = cf.copy(entries = cf.entries + (arg -> ContextEntry(did)))
             // _ <- Try(os.write.over(contextFilePath,ncf.asJson.spaces2)).toEither
            yield (ncf,did)
          
          case false => 
            // create a new context file and generate a new did
            for 
              did <- generateDid()
              ncf = ContextFile(Map(arg -> ContextEntry(did)))
             // _ <- Try(os.write(contextFilePath,ncf.asJson.spaces2,createFolders = true)).toEither
            yield (ncf,did)
        }

        contextFileAndDid match {
          case Right((cf,did)) =>
            os.write.over(contextFilePath,cf.asJson.spaces2, createFolders = true)
            println(s"Your DWN Context for $arg has been initialized. Your DID is $did")
          case Left(e) =>
            (s"An error occurred while initializing your DWN Context: $e")
      
        }
      }
    }
  }
  

  val deleteCommand = Command("delete", "Delete something") {
    val optionalArg = Opts.option[String]("optional-arg", "Context Name").withDefault(user)
    (optionalArg).map { arg =>
      // Logic for the "delete" command
      println(s"Deleting something with optional argument: $arg")
    }
  }

  val getCommand = Command("get", "Get something") {
    val optionalArg = Opts.option[String]("optional-arg", "Optional argument").withDefault("default-value")
    (optionalArg).map { arg =>
      // Logic for the "get" command
      println(s"Getting something with optional argument: $arg")
    }
  }

  val relayCommand = Command("relay", "Relay something") {
    Opts.unit.map { _ =>
      // Logic for the "relay" command
      println("Relaying something")
    }
  }
 
  
  def main: Opts[IO[ExitCode]] = {
    val helpFlag = Opts.flag("help", "Show help information").orFalse
    val command: Opts[Unit] = Opts.subcommand(initCommand) orElse Opts.subcommand(deleteCommand) orElse Opts.subcommand(getCommand) orElse Opts.subcommand(relayCommand)
    (command, helpFlag).mapN { (cmd, help) =>
      if (help || cmd == ()) {
        println(helpInformation)
      } else {
        cmd
      }
    }.as(IO.pure(ExitCode.Success))
  }
  