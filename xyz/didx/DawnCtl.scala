//> using toolkit typelevel:latest
//> using packaging.output "dawnctl"
////> using platform "dwnctl"
//> using nativeMode "release-fast"
//> using dep io.circe::circe-core:0.14.6
//> using dep io.circe::circe-parser:0.14.6
//> using dep io.circe::circe-generic:0.14.6

package xyz.didx


import cats.effect.*
import cats.syntax.all.*
import com.monovore.decline.*
import com.monovore.decline.effect.*
import io.circe.*
import io.circe.parser.*
import io.circe.syntax.*
import io.circe.Encoder.encodeJsonObject

import fs2.*
import java.nio.file.Files
import java.nio.file.Paths

object DawnCtl extends CommandIOApp("dawnctl", "A command-line interface to your DWN Context") :
  val prompt = ">> "
  val exitCommand = "exit"
  def generateDid(): String = {
    // Replace with your logic to generate the DID
    "did:dwn:123456789abcdefghi"
  }

  val helpInformation: String = """
  |Usage: dawnctl [command] [options]
  |Command: init [optional-arg]
  |Initialize your DWN Context. A DID generated by the DWN Network will be stored in the Context file <$user.home/.dawn/dawn.conf>
  |Command: delete
  |Delete something
  |Command: get [optional-arg]
  |Get something
  |Command: relay
  |Relay something
  |Options:
  |  --help
  |    This help information
  """
  val initCommand = Command("init", "Initialize your DWN Context. A DID generated by the DWN Network will be stored in the Context file <$user.home/.dawn/dawn.conf>") {
    val optionalArg = Opts.option[String]("optional-arg", "Context Name").withDefault(System.getProperty("user.name"))
    (optionalArg).map { arg =>
      // Logic for the "init" command
      val userDir = System.getProperty("user.home")
      val dawnDir = s"$userDir/.dawn"
      val contextFile = s"$dawnDir/dawn.conf"

      // Create the invisible directory if it doesn't exist
      val dir = new java.io.File(dawnDir)
      if (!dir.exists()) dir.mkdir()

      val generatedDid = generateDid() // Replace with your logic to generate the DID

      val json = Json.obj(arg -> Json.obj("did" -> Json.fromString(generatedDid)))

      // Write the JSON to the context file using Circe
      val writeResult = IO {
        val jsonString = json.spaces2
        Files.write(Paths.get(contextFile), jsonString.getBytes)
      }

      writeResult.flatMap { _ =>
        IO {
          println(s"Initializing with optional argument: $arg")
          println(s"Context file will be stored at: $contextFile")
        }
      }
    }
  }

  val deleteCommand = Command("delete", "Delete something") {
    val optionalArg = Opts.option[String]("optional-arg", "Context Name").withDefault("default-value")
    (optionalArg).map { arg =>
      // Logic for the "delete" command
      val userDir = System.getProperty("user.home")
      val dawnDir = s"$userDir/.dawn"
      val contextFile = s"$dawnDir/dawn.conf"

      // Read the existing JSON from the context file using Circe
      val existingJson = IO {
        val jsonString = new String(Files.readAllBytes(Paths.get(contextFile)))
        parse(jsonString).getOrElse(Json.Null)
      }

      // Remove the specified context entry from the JSON
      val updatedJson = existingJson.map { json =>
        val updatedObject:JsonObject = json.asObject.map(_.remove(arg)).getOrElse(JsonObject.empty)
        updatedObject.asJson.spaces2
      }

      // Write the updated JSON to the context file using Circe
      val writeResult = updatedJson.flatMap { updatedJsonString =>
       IO {
        val jsonString = updatedJsonString.toString
        Files.write(Paths.get(contextFile), jsonString.getBytes)
      }
}

      writeResult.flatMap { _ =>
        IO {
          println(s"Deleting context entry: $arg")
          println(s"Context file updated: $contextFile")
        }
      }
    }
  }

  val getCommand = Command("get", "Get something") {
    val optionalArg = Opts.option[String]("optional-arg", "Optional argument").withDefault("default-value")
    (optionalArg).map { arg =>
      // Logic for the "get" command
      println(s"Getting something with optional argument: $arg")
    }
  }

  val relayCommand = Command("relay", "Relay something") {
    Opts.unit.map { _ =>
      // Logic for the "relay" command
      println("Relaying something")
    }
  }
 
  
  def main: Opts[IO[ExitCode]] = {
    val helpFlag = Opts.flag("help", "Show help information").orFalse
    val command = Opts.subcommand(initCommand) orElse Opts.subcommand(deleteCommand) orElse Opts.subcommand(getCommand) orElse Opts.subcommand(relayCommand)
    (command, helpFlag).mapN { (cmd, help) =>
      if (help || cmd == IO.unit) {
        println(helpInformation)
      } else {
        cmd
      }
    }.as(IO.pure(ExitCode.Success))
  }
  