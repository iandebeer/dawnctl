package xyz.didx


import cats.effect.*
import cats.syntax.all.*
import com.monovore.decline.*
import com.monovore.decline.effect.*
import io.circe.*
import io.circe.parser.*
import io.circe.syntax.*
import io.circe.generic.semiauto.*
import io.circe.Encoder.encodeJsonObject

import os.*

import fs2.*
import scala.util.Try
import fs2.concurrent.Channel
import java.net.URI


object DawnCtl extends CommandIOApp("dawnctl", "A command-line interface to your DWN Context") : 
  enum ChannelType(agent: URI):
    case Slack extends ChannelType(URI("https://slack.com/api/chat.postMessage"))
    case WhatsApp extends ChannelType(URI("https://api.whatsapp.com/send"))
    case Signal extends ChannelType(URI("https://signal.org/api/v1/send"))
    case Telegram extends ChannelType(URI("https://api.telegram.org/bot"))
    case Email extends ChannelType(URI("smtp://smtp.gmail.com:587"))
    case SMS extends ChannelType(URI("https://api.twilio.com/2010-04)-01/Accounts/ACXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX/Messages.json"))
    def fromString(s: String): Either[Throwable, ChannelType] = 
      s match
        case "slack" => Right(Slack)
        case "whatsapp" => Right(WhatsApp)
        case "signal" => Right(Signal)
        case "telegram" => Right(Telegram)
        case "email" => Right(Email)
        case "sms" => Right(SMS)
        case _ => Left(new Exception("Invalid Channel Type"))
    override def toString(): String = 
      this match
        case Slack => "slack"
        case WhatsApp => "whatsapp"
        case Signal => "signal"
        case Telegram => "telegram"
        case Email => "email"
        case SMS => "sms"
    

  case class Channels(channel: String, channelDid: String)
  given Encoder[Channels] = deriveEncoder[Channels]
  given Decoder[Channels] = deriveDecoder[Channels]
 // case class Context(did: String)
  case class ContextEntry(did: String, alias: Option[String] = None, keyStorePath: Option[String] = None, keyStorePassword: Option[String] = None, publicKey: Option[String] = None)

  given Encoder[ContextEntry] = deriveEncoder[ContextEntry]
  given Decoder[ContextEntry] = deriveDecoder[ContextEntry]

  case class ContextFile(entries:Map[String,ContextEntry])

  given Encoder[ContextFile] = deriveEncoder[ContextFile]
  given Decoder[ContextFile] = deriveDecoder[ContextFile]


  val prompt = ">> "
  val exitCommand = "exit"
  def generateDid(): Either[Throwable,String] = {
    // Replace with your logic to generate the DID
    Right("did:dwn:123456789abcdefghi")
  }

  val helpInformation: String = """
  |Usage: dawnctl [command] [options]
  |Command: init [optional-arg]
  |Initialize your DWN Context. A DID generated by the DWN Network will be stored in the Context file <$user.home/.dawn/dawn.conf>
  |Command: delete
  |Delete something
  |Command: get [optional-arg]
  |Get something
  |Command: relay
  |Relay something
  |Options:
  |  --help
  |    This help information
  """
  val user = System.getProperty("user.name")
  val userDir = os.home
  val dawnDir = userDir / ".dawn"
  val contextFilePath = dawnDir / "dawn.conf"
  def readContextFile(name : String): Either[Throwable, ContextFile] = 
    Try(os.exists(contextFilePath)).toEither.flatMap {
          case true => 
            //read the content of the file and parse the json to case class ContextFile 
            val contextFileContent = Right(os.read(contextFilePath))
            for 
              content <- contextFileContent
              json <- parse(content)
              cf <- json.as[ContextFile]
            yield (cf)
          case false => 
            // create a new context file and generate a new did
              Right(ContextFile(Map()))
             // _ <- Try(os.write(contextFilePath,ncf.asJson.spaces2,createFolders = true)).toEither
           
        }
  def updateContextFileWithDid(name : String, cf: ContextFile): Either[Throwable, (ContextFile,String)] = 
    for    
      // check if the context name already exists and return the did or generate a new did
      did <- cf.entries.get(name) match {
        case Some(entry) => 
          println(s"Context for $name has already been initialized - ignore")   //Right(entry.did)
          entry.did.asRight
        case None => generateDid()
      }
      ncf = cf.copy(entries = cf.entries + (name -> ContextEntry(did)))
      _ <- Try(os.write.over(contextFilePath,ncf.asJson.spaces2,createFolders = true)).toEither
    yield (ncf,did)
          
        
  val initCommand: Command[Unit] = Command("init", "Initialize your DWN Context. A DID generated by the DWN Network will be stored in the Context file <$user.home/.dawn/dawn.conf>") {
    val contextName = Opts.option[String]("context-name", "Context Name").withDefault(user)
    (contextName).map { arg => {
      // Check if the context file already exists
        readContextFile(arg) match {
          case Right(cf) =>
            for 
              contextFile_Did <- updateContextFileWithDid(arg,cf)
              _ <- Try(os.write.over(contextFilePath,contextFile_Did._1.asJson.spaces2)).toEither

            yield println(s"Your DWN Context has been initialized for $arg with DID: ${contextFile_Did._2}")
          case Left(e) =>
            println(s"An error occurred while initializing your DWN Context: $e")
        }
      }
    }
  }
  

  val deleteCommand = Command("delete", "Delete your DWN Context for a given context name") {
    val contextName = Opts.option[String]("context-name", "Context Name").withDefault(user)
    (contextName).map { arg =>
      // delete the entry dron the config file matching the context name
      readContextFile(arg) match {
        case Right(cf) =>
          val ncf = cf.copy(entries = cf.entries - arg)
          Try(os.write.over(contextFilePath,ncf.asJson.spaces2)).toEither
          println(s"Your DWN Context has been deleted for $arg")
        case Left(e) =>
          println(s"An error occurred while deleting your DWN Context: $e")
      }
    }
  }

  val getCommand = Command("get", "Get context for a given context name") {
    val contextName = Opts.option[String]("context-name", "Context Name").withDefault(user)
    val outputPath = Opts.option[String]("output-path", "Output Path").withDefault(user)

    (contextName).map { arg =>
       readContextFile(arg) match {
        case Right(cf) =>
          cf.entries.get(arg) match {
            case Some(entry) => println(s"Your DWN Context for $arg is ${entry.did}")
            case None => println(s"Your DWN Context for $arg is not initialized")
          }
        case Left(e) =>
          println(s"An error occurred while getting your DWN Context: $e")
      }
    }
  }

  val relayCommand = Command("relay", "Relay something") {
    Opts.unit.map { _ =>
      // Logic for the "relay" command
      println("Relaying something")
    }
  }
 
  
  def main: Opts[IO[ExitCode]] = {
    val helpFlag = Opts.flag("help", "Show help information").orFalse
    val command: Opts[Unit] = Opts.subcommand(initCommand) orElse Opts.subcommand(deleteCommand) orElse Opts.subcommand(getCommand) orElse Opts.subcommand(relayCommand)
    (command, helpFlag).mapN { (cmd, help) =>
      if (cmd == () && !help) {
        cmd
      } else {
        println(helpInformation)
      }
    }.as(IO.pure(ExitCode.Success))
  }
  